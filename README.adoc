= image:https://raw.githubusercontent.com/micronaut-projects/static-website/gh-pages/images/favicon-32x32.png[] https://alvarosanchez.github.io/micronaut-workshop/[Micronaut Workshop]
Alvaro Sanchez-Mariscal <alvaro.sanchezmariscal@gmail.com>
:toc: left
:toclevels: 4
:source-highlighter: highlightjs
:icons: font
:imagesdir: ./images

++++
<a href="https://github.com/alvarosanchez/micronaut-workshop"><img style="position: fixed; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"></a>
++++

Introductory workshop about http://micronaut.io[Micronaut].

== Software Requirements

In order to do this workshop, you need the following:

* Linux or MacOS with shell access, and the following installed:
    - `curl`.
    - `wget`.
    - `unzip`.
    - `git`.
* JDK 8.
* Docker.

=== Micronaut CLI

==== Option 1 (recommended): using SDKMAN!

1. Install http://sdkman.io[SDKMAN!] if you haven't done so already.
2. Install Micronaut CLI:

    $ sdk install micronaut

3. Ensure the CLI is installed properly:

    $ mn --version
    | Micronaut Version: 1.0.0-SNAPSHOT
    | Groovy Version: 2.5.0-rc-3
    | JVM Version: 1.8.0_131

==== Option 2: from a ZIP file

1. Grab the latest `-dist.zip` file from https://oss.sonatype.org/content/groups/public/io/micronaut/cli/1.0.0-SNAPSHOT/[]:

    $ wget https://oss.sonatype.org/content/groups/public/io/micronaut/cli/1.0.0-SNAPSHOT/cli-1.0.0-20180526.063403-21-dist.zip -O micronaut-cli.zip

2. Unzip it under a desired location (eg: `/usr/local/micronaut`):

    $ sudo unzip micronaut-cli.zip -d /usr/local/micronaut
    Password:
    Archive:  micronaut-cli.zip
      inflating: /usr/local/micronaut/cli-1.0.0-SNAPSHOT.jar
      inflating: /usr/local/micronaut/LICENSE
      creating: /usr/local/micronaut/bin/
      inflating: /usr/local/micronaut/bin/mn.bat
      inflating: /usr/local/micronaut/bin/mn
      creating: /usr/local/micronaut/media/
      inflating: /usr/local/micronaut/media/mn.icns

3. Link the `mn` command-line into a directory belonging to your `$PATH` (eg: `/usr/local/bin`):

    $ ln -s /usr/local/micronaut/bin/mn /usr/local/bin/

4. Ensure the CLI is installed properly:

    $ mn --version
    | Micronaut Version: 1.0.0-SNAPSHOT
    | Groovy Version: 2.5.0-rc-3
    | JVM Version: 1.8.0_131

=== Clone this repository

Once done, you can clone this repo:

----
git clone https://github.com/alvarosanchez/ratpack-101.git
----

NOTE: You will find each exercise's template files on each `exNN` folder. Solution is always inside a `solution` folder. To highlight the actions you actually need to perform, an icon is used: icon:hand-o-right[]

== Application architecture 

Throughout this workshop, we will be creating a football (soccer) management system.

ifdef::generate-diagrams[]
[plantuml, football-diagram, png]
....
together {
    node Fixtures
    database Mongo
}

together {
    node Clubs
    database H2
}

Clubs -> H2
H2 -[hidden]- Fixtures
Fixtures -> Mongo
Fixtures -> Clubs
....
endif::[]

image::football-diagram.png[]

* `clubs` is the microservice responsible for managing clubs. It uses GORM for
  Hibernate as a data access layer.
* `fixtures` manages all game fixtures, storing its data in MongoDB. For the 
  teams playing in a game, it doesn't store their full details, but rather their 
  ID. It has a service-discovery-enabled HTTP client to fetch club details from 
  the `clubs` microservice.

:numbered:

== Getting started with the Micronaut CLI (15 minutes)

TIP: Change to the `ex01` directory to work on this exercise

The Micronaut CLI is the recommended way to create new Micronaut projects. The 
CLI includes commands for generating specific categories of projects, allowing 
you to choose between build tools, test frameworks, and even pick the language 
you wish to use in your application. The CLI also provides commands for generating 
artifacts such as controllers, client interfaces, and serverless functions.

The `create-app` command is the starting point for creating Micronaut applications.
The CLI is based on the concept of **profiles**. A profile consist of a project
template (or skeleton), optional features, and profile-specific commands. Commands 
from a profile typically are specific to the profile application type; for example, 
the `service` profile (designed for creation of microservice applications) provides 
the `create-controller` and `create-client` commands.

=== Listing profiles

icon:hand-o-right[] You can list the available profiles with the `list-profiles` command:

----
$ mn list-profiles                                                                                     
| Available Profiles
--------------------
* federation - The federation profile
* service - The service profile
* base - The base profile
----

TIP: The Micronaut team is actively working on new profiles, and eventually they 
will be available.

Applications generated from a profile can be personalised with **features**. A 
feature further customises the newly created project by adding additional 
dependencies to the build, more files to the project skeleton, etc.

=== Getting information about a profile

icon:hand-o-right[] To see all the features of a profile, you can
use the `profile-info` command:

----
$ mn profile-info service                                                                                
Profile: service
--------------------
The service profile

Provided Commands:
--------------------
* help - Prints help information for a specific command
* create-bean - Creates a singleton bean
* create-job - Creates a job with scheduled method
* create-client - Creates a client interface
* create-controller - Creates a controller and associated test

Provided Features:
--------------------
* config-consul - Adds support for Distributed Configuration with Consul (https://www.consul.io)
* discovery-consul - Adds support for Service Discovery with Consul (https://www.consul.io)
* discovery-eureka - Adds support for Service Discovery with Eureka
* groovy - Adds support for Groovy in the application
* hibernate-gorm - Adds support for GORM persistence framework
* hibernate-jpa - Adds support for Hibernate/JPA
* http-client - Adds support for creating HTTP clients
* http-server - Adds support for running a Netty server
* java - Adds support for Java in the application
* jdbc-dbcp - Configures SQL DataSource instances using Commons DBCP
* jdbc-hikari - Configures SQL DataSource instances using Hikari Connection Pool
* jdbc-tomcat - Configures SQL DataSource instances using Tomcat Connection Pool
* junit - Adds support for the JUnit testing framework
* kotlin - Adds support for Kotlin in the application
* mongo-gorm - Configures GORM for MongoDB for Groovy applications
* mongo-reactive - Adds support for the Mongo Reactive Streams Driver
* neo4j-bolt - Adds support for the Neo4j Bolt Driver
* neo4j-gorm - Configures GORM for Neo4j for Groovy applications
* redis-lettuce - Configures the Lettuce driver for Redis
* security-jwt - Adds support for JWT (JSON Web Token) based Authentication
* security-session - Adds support for Session based Authentication
* spek - Adds support for the Spek testing framewokr
* spock - Adds support for the Spock testing framework
* tracing-jaeger - Adds support for distributed tracing with Jaeger (https://www.jaegertracing.io)
* tracing-zipkin - Adds support for distributed tracing with Zipkin (https://zipkin.io)
----

=== Creating and running a _hello galaxy_

As explained avobe, the `create-app` command can be used to create new projects.
It accepts some flags:

.Create-App Flags
|===
|Flag|Description|Example

|`build`
|Build tool (one of `gradle`, `maven` - default is `gradle`)
|`-build maven`

|`profile`
|Profile to use for the project (default is `service`)
|`-profile function-aws`

|`features`
|Features to use for the project, comma-separated
|`-features security-jwt,mongo-gorm`

|`inplace`
|If present, generates the project in the current directory (project name is optional if this flag is set)
|`-inplace`
|===

icon:hand-o-right[] Let's create a _hello galaxy_ project:

----
$ mn create-app hello-galaxy -features groovy
| Application created at /private/tmp/hello-galaxy
----

WARNING: Currently, https://github.com/micronaut-projects/micronaut-profiles/issues/28[there is a bug]
in the CLI that makes it generate a main `Application.java` class regardless of 
the `groovy` feature being selected. However, the main `Application` class can be 
left as is, and we will work with Groovy with the rest of the project.

icon:hand-o-right[] Now, move into the generated `hello-galaxy` folder and let's 
create a controller:

----
$ mn create-controller hello
| Rendered template Controller.groovy to destination src/main/groovy/hello/galaxy/HelloController.groovy
| Rendered template ControllerSpec.groovy to destination src/test/groovy/hello/galaxy/HelloControllerSpec.groovy
----

icon:hand-o-right[] Open the generated `HelloController.groovy` with your favourite 
IDE and make it return "Hello Micronauts!":

[source,groovy]
----
@Get("/")
String index() {
    return "Hello Galaxy!"
}
----

icon:hand-o-right[] Now, run the application:

    $ MICRONAUT_SERVER_PORT=8080 ./gradlew run

TIP: Micronaut by default runs on a random port. This helps running multiple 
instances of a service. However, the port can be easily fixed by setting a
configuration variable, or simply by exposing an environment variable as we
did with `MICRONAUT_SERVER_PORT=8080`

You will see a line similar to the following once the application has started

    14:40:01.187 [main] INFO  io.micronaut.runtime.Micronaut - Startup completed in 957ms. Server Running: http://localhost:8080

icon:hand-o-right[] Then, on another shell, make a request to your service:

----
$ curl 0:8080/hello
Hello Galaxy!
----

=== Write an automated test

While testing manually is acceptable in some situations, going forward it is 
better to have automated tests to exercise our applications. Fortunately,
Micronaut makes testing super easy!

icon:hand-o-right[] Change the generated `src/test/groovy/hello/galaxy/HelloControllerSpec.groovy`
to look like this:

[source,groovy]
----
class HelloControllerSpec extends Specification {

    @Shared @AutoCleanup EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer) // <1>
    @Shared @AutoCleanup RxHttpClient client = embeddedServer.applicationContext.createBean(RxHttpClient, embeddedServer.getURL()) //<2>

    void "test index"() {
        given:
        String response = client.toBlocking().retrieve("/hello") //<3>

        expect:
        response == "Hello Galaxy!"
    }
}
----
<1> Running an embedded server
<2> Obtaining a reactive HTTP client attached to our embedded server
<3> As the client is non-blocking by default, we want to block in tests to make sure 
    we get a result before the test finishes. Also, the `retrieve` method returns
    the response as a String.

icon:hand-o-right[] Then, run the tests:

    ./gradlew test

Once finished, you should see an output similar to:

    BUILD SUCCESSFUL in 6s

== Creating the Clubs microservice (30 minutes)

TIP: Change to the `ex02/clubs` directory to work on this exercise. The project 
has been already created for you, no need to run `mn create-app` this time.

In this exercise we are creating the `clubs` microservice.

icon:hand-o-right[] Let's define first a `Club` domain class under
`src/main/groovy/clubs/domain/Club.groovy` with 2 string attributes:
`name` (mandatory) and `stadium` (optional).

WARNING: Unlike Grails, when using GORM in Micronaut you need to annotate your
entities with `grails.gorm.annotation.Entity`, as in Micronaut there is no
conventional folder such as `grails-app/domain`.

icon:hand-o-right[] Next, define a 
http://gorm.grails.org/latest/hibernate/manual/index.html#dataServices[GORM data service]
named `ClubService` as an interface with the following operations:

* `int count()`
* `Club save(@NotBlank String name, @NotBlank String stadium)`
* `List<Club> findAll()`

icon:hand-o-right[] Now, let's test our service:

[source,groovy]
----
class ClubServiceSpec extends Specification {

    @Shared @AutoCleanup EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer)
    @Shared ClubService service = embeddedServer.applicationContext.getBean(ClubService) // <1>

    @Rollback
    void "it can work with clubs"() {
        expect:
        service.count() == 0

        when:
        service.save("Real Madrid", "Bernabeu")

        then:
        service.count() == 1

        when:
        List<Club> clubs = service.findAll()

        then:
        clubs.size() == 1
    }
}
----
<1> Instead of any kind of injection, we simply get the bean from the application context.
